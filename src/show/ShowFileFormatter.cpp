#include "ShowFileFormatter.h"

#include <QStandardPaths>
#include <QTextStream>
//#include <QTextCodec>

#include "MediaListModel.h"
#include "LightPresetModel.h"
#include "LightPresetData.h"
#include "SequenceEditorGui.h"
#include "IF_ScriptEngineInterface.h"

#include "ShowFileStrings.h"
#include "HtmlOptimizer.h"

#include "modelViewRules.h"


#define  PROJECT_FILE_HEADER\
   QString("<!-- # This file is generated by Starvax Meteor Player\n"\
           "     # Please do not edit manually-->\n\n")

ShowFileFormatter::ShowFileFormatter( const IF_ScriptEngineInterface &script,
                                      const QAbstractListModel &mediaModelLineA,
                                      const QAbstractListModel & mediaModelLineB,
                                      const QAbstractListModel &lightsetModel,
                                      HtmlOptimizer & optimizer,
                                      const SequenceEditorGui & sequencerGui) :
   m_script( script),
   m_mediaModelLineA( mediaModelLineA),
   m_mediaModelLineB( mediaModelLineB),
   m_lightsetModel( lightsetModel),
   m_optimizer( optimizer),
   m_sequencerGui( sequencerGui)
{
   setFolder(QDir());
}

/**
 * set the path for output show file at \p showFolder, if it's
 * valid and exists. Otherwise a default location is set
 */
void ShowFileFormatter::setFolder(const QDir &showFolder)
{
   if (showFolder.exists())
   {
      m_showPath = showFolder;
   }
   else
   {
      m_showPath = QDir( QStandardPaths::standardLocations( QStandardPaths::DocumentsLocation ).at(0));
   }
}

QString ShowFileFormatter::formatShowFile()
{
   QString outputString;
   QTextStream  output( &outputString);

   output.setEncoding( QStringConverter::Utf8);

   output << PROJECT_FILE_HEADER;

   formatPlaylist(output);
   formatLightTransitions(output);
   formatSequencer(output);
   formatScript(output);

   return outputString;
}

void ShowFileFormatter::formatPlaylist(QTextStream & output)
{
   formatPlaylistForLine( output, m_mediaModelLineA,
                          PLAYLIST_LINE_A_START_TAG, PLAYLIST_LINE_A_END_TAG);
   formatPlaylistForLine( output, m_mediaModelLineB,
                          PLAYLIST_LINE_B_START_TAG, PLAYLIST_LINE_B_END_TAG);
}

void ShowFileFormatter::formatPlaylistForLine( QTextStream & output, const QAbstractListModel & m_mediaModel,
                                               const QString & openTag, const QString & closeTag)
{
   output << openTag << "\n";

   for( int i = 0; i < m_mediaModel.rowCount(); i++ )
   {
      /* write each track filename */
      QString absolutePath = m_mediaModel.index(i).data( modelViewRules::Serialize ).toString();

      output << m_showPath.relativeFilePath( absolutePath );
      output << "\n";
   }

   output << closeTag << "\n\n";
}

void ShowFileFormatter::formatLightTransitions(QTextStream & output)
{
   int numOfEntries = m_lightsetModel.rowCount();

   output << LIGHTSET_START_TAG << "\n";

   for (int i = 0; i < numOfEntries; i++)
   {
      const LightPresetData & descriptor =
            m_lightsetModel.index(i).data(modelViewRules::Binary).value<LightPresetData>();

      output << "\"" << descriptor.name() << "\"  " ;
      output << descriptor.fadeTime();

      foreach ( double level, descriptor.levelList() )
      {
         output << "  " << level;
      }

      output << "\n";
   }

   output << LIGHTSET_END_TAG<< "\n\n";
}

void ShowFileFormatter::formatSequencer(QTextStream & output)
{
   QString content = m_sequencerGui.scriptContent();

   output << SEQUENCER_START_TAG << "\n";
   output << content;

   if ( ! ((content.endsWith("\n")) || (content.endsWith("\r"))) )
   {
      output << "\n";
   }

   output << SEQUENCER_END_TAG << "\n\n";
}

void ShowFileFormatter::formatScript(QTextStream & output)
{
   QString nativeHtml;
   m_script.getScriptContent( nativeHtml);

   QString optimized = m_optimizer.optimizeHtml( & nativeHtml);

   output << optimized;
}

