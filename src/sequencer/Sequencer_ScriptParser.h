#ifndef SEQUENCER_SCRIPTPARSER_H
#define SEQUENCER_SCRIPTPARSER_H

#include <QList>

namespace Sequencer {

class LineParser;
class Instruction;
class InstructionFactory_IF;

/**
 * The ScriptParser class processes a script (passed as a list of strings)
 * to extract a list of \a Sequencer::Instruction.
 * This class collects what lines are syntactically wrong but does not check
 * for relation between lines (for example does not check that each 'repeat'
 * has its own 'end').
 */
class ScriptParser
{
public:
   /** an error in script */
   struct Error {
      int line; /**< line of source file */
      QString error;

      Error( int aLine, const QString & aError) :
         line(aLine),
         error( aError)
      {}
   };

   ScriptParser(LineParser & lineParser,
                InstructionFactory_IF & instructionFactory);

   /**
    * parse a script, passed as a list of lines
    * @param script
    */
   void parse(const QStringList & script);

   /**
    * @return the list of errors generated by last call to \a parse.
    * @note: every time \a parse is called, the list of errors is reset.
    */
   const QList<Error> & errorList() const {
      return m_errorList;
   }

   /**
    * @return the list of instructions that make up the script. This
    * is built on last call to \a parse.
    */
   QList<Instruction *> & instructionSequence() {
      return m_instructionSequence;
   }


private:
   LineParser & m_lineParser;
   InstructionFactory_IF & m_instructionFactory;

   QList<Instruction *> m_instructionSequence;
   QList<Error> m_errorList;
};

}  // namespace Sequencer

#endif // SEQUENCER_SCRIPTPARSER_H

